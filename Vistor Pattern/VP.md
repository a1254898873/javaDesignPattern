访问者模式（Vistor Pattern）是一种将数据结构与数据操作分离的设计模式。是指封装一些作用于某种数据结构中的各种元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作，访问者模式属于行为型模式。

访问者模式的基本思想是针对系统中拥有的某些固定类型的对象结构（元素），在其内提供一个 accept 方法用来接受访问者对象的访问。不同的访问者对同一元素的访问内容不同，使得相同的元素集合可以产生不同的元素结果。accept 方法可以接受不同的访问者对象，然后在内部将自己转发到访问者对象 visit 方法内。

访问者模式的核心思想是解耦数据结构与数据操作，使得对元素的操作具备优秀的扩展性，我们可以通过扩展不同的数据操作类型（访问者）实现对相同元素的不同操作。



#### 访问者模式角色

从上面示例中，我们可以得出访问者模式主要有 5 个角色：

- 抽象访问者（Vistor）：接口或者抽象类都可以（如示例中的 ICustomer）。这个角色主要是定义对具体元素的 visit 方法，参数就是具体元素，理论上来说方法数等于元素个数。所以如果元素不稳定经常变化的话，那么访问者是要一直修改的，并不适合使用访问者模式。
- 具体访问者(ConcreteVistor）：实现对具体元素的访问（如示例中的 CustomerA）。
- 抽象元素（Element)：接口或者抽象类。定义了一个接受访问者访问的方法 accept（如示例中的 IRecipe）。
- 具体元素（ConcreteElement）：提供接受访问者访问的具体实现，通常都是采用 `visitor.visit()` 来实现（如示例中的 Cabbage 和 Meat）。
- 结构对象（ObjectStruture）：用来维护元素，并提供一个方法来接受访问者访问所有的元素（如示例中的 RestaurantMenu）。

#### 访问者模式适用场景

1. 数据结构要稳定，但是作用于数据结构上的操作经常变化（如上面示例中菜的种类要稳定，但是顾客可以不断变化）。
2. 需要对不同数据类型（元素）进行操作，而不使用分支判断具体类型的场景。

#### 访问者模式优点

1. 解耦了数据结构和数据操作，使得操作集合可以独立变化，非常容易扩展。
2. 每种角色各司其职，符合单一职责原则。

#### 访问者模式缺点

1. 增加元素类型困难，一旦增加元素就必须要修改访问者源码，违反了开闭原则，也不利于维护。
2. 违背了依赖倒置原则，比如我们示例中的访问者接口，定义的 visit 方法依赖的是具体元素而不是抽象元素。